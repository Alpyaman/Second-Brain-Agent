from sqlalchemy.orm import Session
from typing import List

from app.core.database import get_db
from app.schemas.products import Product as ProductSchema, ProductCreate, ProductUpdate
from app.services.products import ProductService
from app.models.products import Product as ProductModel # For type hinting

# --- Controller Mapping (Pattern 2) ---
# This pattern is more relevant for frameworks that dynamically discover controllers.
# In FastAPI, we explicitly define routers. However, we can conceptually think of
# this file as defining the "controller mapping" for product-related endpoints.
# For OpenAPI generation, FastAPI uses Pydantic models and route decorators.

router = APIRouter()

# --- Endpoint: Fetch all products ---
@router.get(
    "/",
    response_model=List[ProductSchema],
    summary="List all products",
    description="Retrieve a list of all available products. Supports pagination via `skip` and `limit` query parameters.",
)
async def read_products(
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db)
):
    """
    Fetches a list of products with optional pagination.

    Args:
        skip: Number of products to skip from the beginning.
        limit: Maximum number of products to return.
        db: Database session dependency.

    Returns:
        A list of Product schemas.
    """
    service = ProductService(db)
    products = service.get_products(skip=skip, limit=limit)
    return products

# --- Endpoint: Fetch a single product by ID ---
@router.get(
    "/{product_id}",
    response_model=ProductSchema,
    summary="Get a product by ID",
    description="Retrieve details of a specific product using its unique identifier.",
)
async def read_product(
    product_id: int,
    db: Session = Depends(get_db)
):
    """
    Fetches a single product by its ID.

    Args:
        product_id: The ID of the product to retrieve.
        db: Database session dependency.

    Returns:
        The Product schema for the requested product.
    """
    service = ProductService(db)
    try:
        db_product = service.get_product(product_id)
        return db_product
    except HTTPException as e:
        raise e # Re-raise the HTTPException from the service

# --- Endpoint: Add a new product ---
@router.post(
    "/",
    response_model=ProductSchema,
    status_code=status.HTTP_201_CREATED,
    summary="Create a new product",
    description="Add a new product to the inventory. Requires product details in the request body.",
)
async def create_product(
    product: ProductCreate,
    db: Session = Depends(get_db)
):
    """
    Creates a new product.

    Args:
        product: The ProductCreate schema containing product data.
        db: Database session dependency.

    Returns:
        The newly created Product schema.
    """
    service = ProductService(db)
    try:
        db_product = service.create_product(product)
        return db_product
    except Exception as e:
        # Generic error handling for unexpected issues during creation
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An unexpected error occurred while creating the product: {e}"
        )

# --- Endpoint: Update an existing product ---
@router.put(
    "/{product_id}",
    response_model=ProductSchema,
    summary="Update an existing product",
    description="Modify an existing product's details using its unique identifier. Accepts partial updates.",
)
async def update_product(
    product_id: int,
    product_update: ProductUpdate,
    db: Session = Depends(get_db)
):
    """
    Updates an existing product.

    Args:
        product_id: The ID of the product to update.
        product_update: The ProductUpdate schema with fields to update.
        db: Database session dependency.

    Returns:
        The updated Product schema.
    """
    service = ProductService(db)
    try:
        db_product = service.update_product(product_id, product_update)
        return db_product
    except HTTPException as e:
        raise e # Re-raise the HTTPException from the service
    except Exception as e:
        # Generic error handling for unexpected issues during update
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An unexpected error occurred while updating the product: {e}"
        )

# --- Endpoint: Delete a product ---
@router.delete(
    "/{product_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete a product",
    description="Remove a product from the inventory using its unique identifier.",
)
async def delete_product(
    product_id: int,
    db: Session = Depends(get_db)
):
    """
    Deletes a product.

    Args:
        product_id: The ID of the product to delete.
        db: Database session dependency.

    Returns:
        No content on successful deletion.
    """
    service = ProductService(db)
    try:
        service.delete_product(product_id)
        return # FastAPI automatically returns 204 No Content for empty responses
    except HTTPException as e:
        raise e # Re-raise the HTTPException from the service
    except Exception as e:
        # Generic error handling for unexpected issues during deletion
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An unexpected error occurred while deleting the product: {e}"
        )